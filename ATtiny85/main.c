//ATtiny25/45/85 DDS waveform generator
//Using the PWM1/TIMER1 to generate waveforms
//See Atmel DOC2542
//PWM generated by PCLK/4, or CLK / 1
//ISR need 20 ticks for overhead + 40 ticks for math / accumulator

//#include <avr/pgmspace.h>						//optional: waveform data stored in program space
#include "gpio.h"

//hardware configuration
#define OUT_PORT		PORTB
#define OUT_DDR			DDRB
#define OUT1			((1<<1) | (1<<0))	//OC1A = PB1, _OC1A = PB0
#define OUT2			((1<<4) | (1<<3))	//OC1B = PB4, _OC1B = PB3
#define DDS_STEPPING	(DDS_50hz + DDS_10hz)	//phase stepping for desired output frequency
//#define DDS_USEPLL							//comment out if PLL is not used
//when PLL is used, prescaler = 2:1, PCLK = 64Mhz
//when PLL is not used, prescaler = 1:1, CLK = 8Mhz

//for debug only
#define LED_PORT		PORTB
#define LED_DDR			DDRB
#define LED				(1<<2)
//end hardware configuration

//global defines
//frequency calculations
//Stepping = Fout * 2^32 / Fclk, for 32-bit phase accumulators
//Fclk = 8Mhz / 2 = 4Mhz
#define DDS_0hz1		(DDS_1hz  /10)		//phase stepping for 0.1Hz
#define DDS_0hz2		(DDS_1hz  / 5)		//phase stepping for 0.5Hz
#define DDS_0hz25		(DDS_1hz  / 4)		//phase stepping for 0.25Hz
#define DDS_0hz5		(DDS_1hz   / 2)		//phase stepping for 0.5Hz
#define DDS_1hz			(DDS_10hz  / 10)	//phase stepping for 1Hz
#define DDS_2hz			(DDS_10hz  / 5)		//phase stepping for 2Hz
#define DDS_5hz			(DDS_10hz  / 2)		//phase stepping for 5Hz
#define DDS_10hz		(DDS_100hz /10)		//phase stepping for 10Hz
#define DDS_20hz		(DDS_100hz / 5)		//phase stepping for 20Hz
#define DDS_25hz		(DDS_100hz / 4)		//phase stepping for 25Hz
#define DDS_50hz		(DDS_100hz / 2)		//phase stepping for 50Hz
#define DDS_100hz		(DDS_1Khz  /10)		//phase stepping for 100Hz
#define DDS_200hz		(DDS_1Khz  / 5)		//phase stepping for 200Hz
#define DDS_250hz		(DDS_1Khz  / 4)		//phase stepping for 250Hz
#define DDS_500hz		(DDS_1Khz  / 2)		//phase stepping for 500Hz
#define DDS_1Khz		(DDS_10Khz /10)		//phase stepping for 1Khz
#define DDS_2Khz		(DDS_10Khz / 5)		//phase stepping for 2Khz
#define DDS_2K5hz		(DDS_10Khz / 4)		//phase stepping for 2.5Khz
#define DDS_5Khz		(DDS_10Khz / 2)		//phase stepping for 5Khz

#if defined(DDS_USEPLL)	//use 64Mhz PCLK, 2:1 prescaler
#define DDS_50Khz		3435973837ul		//phase stepping for 100Khz, 64Mhz oscillator, 4:1 prescaler, 256 bit timer base -> stepping = (Fout * 2^32 / (64Mhz / 4 / 256)
#define DDS_25Khz		(DDS_50Khz / 2)
#define DDS_10Khz		(DDS_50Khz / 5)
#else					//use 8Mhz oscillator, 1:1 prescaler
#define DDS_10Khz		1374389535ul		//phase stepping for 10Khz, 8Mhz oscillator, 1:1 prescaler, 256 bit timer base -> stepping = (Fout * 2^32 / (8Mhz / 1 / 256)
#endif


//global variables
volatile uint32_t dds_accumulator;			//phase accumulator
uint8_t *dds_msb;							//points to dds_accumlator's MSB
volatile uint8_t sDutyCycle;				//duty cycle, shadow variable - not actually needed for ATtiny
const uint8_t *dds_ptr;						//wave table pointer
//waveforms, 256 pints
const uint8_t dds_sin[] /*PROGMEM*/ = {
    127, 129, 132, 134, 137, 139, 141, 144,
    146, 148, 151, 153, 155, 157, 160, 162,
    164, 166, 168, 171, 173, 175, 177, 179,
    181, 183, 185, 187, 189, 190, 192, 194,
    196, 197, 199, 200, 202, 203, 205, 206,
    208, 209, 210, 211, 213, 214, 215, 216,
    217, 218, 218, 219, 220, 220, 221, 222,
    222, 223, 223, 223, 224, 224, 224, 224,
    224, 224, 224, 224, 224, 223, 223, 223,
    222, 222, 221, 220, 220, 219, 218, 218,
    217, 216, 215, 214, 213, 211, 210, 209,
    208, 206, 205, 203, 202, 200, 199, 197,
    196, 194, 192, 190, 189, 187, 185, 183,
    181, 179, 177, 175, 173, 171, 168, 166,
    164, 162, 160, 157, 155, 153, 151, 148,
    146, 144, 141, 139, 137, 134, 132, 129,
    127, 125, 122, 120, 117, 115, 113, 110,
    108, 106, 103, 101, 99, 97, 94, 92,
    90, 88, 86, 83, 81, 79, 77, 75,
    73,	71, 69, 67, 65, 64, 62, 60,
    58, 57,	55, 54, 52, 51, 49, 48,
    46, 45, 44,	43, 41, 40, 39, 38,
    37, 36, 36, 35,	34, 34, 33, 32,
    32, 31, 31, 31, 30,	30, 30, 30,
    30, 30, 30, 30, 30, 31,	31, 31,
    32, 32, 33, 34, 34, 35, 36,	36,
    37, 38, 39, 40, 41, 43, 44, 45,
    46, 48, 49, 51, 52, 54, 55, 57,
    58, 60, 62, 64, 65, 67, 69, 71,
    73, 75, 77, 79, 81, 83, 86, 88,
    90, 92, 94, 97, 99, 101, 103, 106,
    108, 110, 113, 115, 117, 120, 122, 125,
};
/*
const uint8_t dds_triangle[] PROGMEM = {
    30,	32,	33,	35,	36,	38,	39,	41,
    42,	44,	45,	47,	48,	50,	51,	53,
    54,	56,	57,	59,	60,	62,	63,	65,
    66,	68,	69,	71,	72,	74,	75,	77,
    79,	80,	82,	83,	85,	86,	88,	89,
    91,	92,	94,	95,	97,	98,	100,	101,
    103,	104,	106,	107,	109,	110,	112,	113,
    115,	116,	118,	119,	121,	122,	124,	125,
    127,	129,	130,	132,	133,	135,	136,	138,
    139,	141,	142,	144,	145,	147,	148,	150,
    151,	153,	154,	156,	157,	159,	160,	162,
    163,	165,	166,	168,	169,	171,	172,	174,
    176,	177,	179,	180,	182,	183,	185,	186,
    188,	189,	191,	192,	194,	195,	197,	198,
    200,	201,	203,	204,	206,	207,	209,	210,
    212,	213,	215,	216,	218,	219,	221,	222,
    224,	222,	221,	219,	218,	216,	215,	213,
    212,	210,	209,	207,	206,	204,	203,	201,
    200,	198,	197,	195,	194,	192,	191,	189,
    188,	186,	185,	183,	182,	180,	179,	177,
    176,	174,	172,	171,	169,	168,	166,	165,
    163,	162,	160,	159,	157,	156,	154,	153,
    151,	150,	148,	147,	145,	144,	142,	141,
    139,	138,	136,	135,	133,	132,	130,	129,
    127,	125,	124,	122,	121,	119,	118,	116,
    115,	113,	112,	110,	109,	107,	106,	104,
    103,	101,	100,	98,	97,	95,	94,	92,
    91,	89,	88,	86,	85,	83,	82,	80,
    79,	77,	75,	74,	72,	71,	69,	68,
    66,	65,	63,	62,	60,	59,	57,	56,
    54,	53,	51,	50,	48,	47,	45,	44,
    42,	41,	39,	38,	36,	35,	33,	32,
};

const uint8_t dds_sawtooth[] PROGMEM = {
    30,	31,	32,	32,	33,	34,	35,	35,
    36,	37,	38,	38,	39,	40,	41,	41,
    42,	43,	44,	44,	45,	46,	47,	47,
    48,	49,	50,	50,	51,	52,	53,	53,
    54,	55,	56,	57,	57,	58,	59,	60,
    60,	61,	62,	63,	63,	64,	65,	66,
    66,	67,	68,	69,	69,	70,	71,	72,
    72,	73,	74,	75,	75,	76,	77,	78,
    79,	79,	80,	81,	82,	82,	83,	84,
    85,	85,	86,	87,	88,	88,	89,	90,
    91,	91,	92,	93,	94,	94,	95,	96,
    97,	97,	98,	99,	100,	100,	101,	102,
    103,	104,	104,	105,	106,	107,	107,	108,
    109,	110,	110,	111,	112,	113,	113,	114,
    115,	116,	116,	117,	118,	119,	119,	120,
    121,	122,	122,	123,	124,	125,	125,	126,
    127,	128,	129,	129,	130,	131,	132,	132,
    133,	134,	135,	135,	136,	137,	138,	138,
    139,	140,	141,	141,	142,	143,	144,	144,
    145,	146,	147,	147,	148,	149,	150,	150,
    151,	152,	153,	154,	154,	155,	156,	157,
    157,	158,	159,	160,	160,	161,	162,	163,
    163,	164,	165,	166,	166,	167,	168,	169,
    169,	170,	171,	172,	172,	173,	174,	175,
    176,	176,	177,	178,	179,	179,	180,	181,
    182,	182,	183,	184,	185,	185,	186,	187,
    188,	188,	189,	190,	191,	191,	192,	193,
    194,	194,	195,	196,	197,	197,	198,	199,
    200,	201,	201,	202,	203,	204,	204,	205,
    206,	207,	207,	208,	209,	210,	210,	211,
    212,	213,	213,	214,	215,	216,	216,	217,
    218,	219,	219,	220,	221,	222,	222,	223,
};

const uint8_t dds_square[] PROGMEM = {
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    224,	224,	224,	224,	224,	224,	224,	224,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
    30,	30,	30,	30,	30,	30,	30,	30,
};
*/

//tmr1 ovf isr
ISR(TIMER1_OVF_vect) {
    //clera the flag - done automatically
    //IO_FLP(LED_PORT, LED);
    OCR1A = sDutyCycle;					//load up the duty cycle first
    dds_accumulator += DDS_STEPPING;	//increment the phase accumulator
    sDutyCycle = dds_ptr[*dds_msb];		//if ram array is used
    //sDutyCycle = pgm_read_byte(dds_ptr+*dds_msb);		//update the duty cycle
    //sDutyCycle = pgm_read_byte(&dds_ptr[*dds_msb]);		//update the duty cycle
    //sDutyCycle = 100;
}

//reset the dds
void dds_init(void) {
#if defined(LED)
    IO_OUT(LED_DDR, LED);				//led as output - debug only
#endif

    //reset the output pins
    IO_OUT(OUT_DDR, OUT1 | OUT2);		//OUT1/2 as output

    //reset the variables
    dds_msb = (uint8_t *) (&dds_accumulator) + 3;	//point dds_msb to dds_accumlator's MSB
    dds_ptr = dds_sin;						//output sin wave
    dds_accumulator = 0;					//reset the phase accumulator
    sDutyCycle = *(dds_ptr+*dds_msb);				//initialize the duty cycle
    //sDutyCycle = pgm_read_byte(dds_ptr+*dds_msb);				//initialize the duty cycle

    //stop the timer
    TCCR1 = (TCCR1 &~0x0f) | (0x00 & 0x0f);	//0x00->stop the timer

#if defined(DDS_USEPLL)
    //set up the PLL/PCLK
    PLLCSR |= (1<<PLLE);					//1->enable PLL
    //wait for PLL to lock
    while ((PLLCSR & (1<<PLOCK)) == 0) continue;	//1->pll has locked, 0->pll has not locked
    PLLCSR |= (1<<PCKE);					//1->enable pll clock
#endif

    TCNT1 = 0;								//reset the counter

    //set up timer1 to perform fast pwm
    TCCR1 &=~(1<<CTC1);						//0->CTC mode disabled, top at 0xff, 1->CTC mode enabled, top at OCR1C
    //configure OC1A/_OC1A
    TCCR1 = (TCCR1 &~((1<<COM1A1) | (1<<COM1A0))) | ((0<<COM1A1) | (1<<COM1A0));	//0b01->set at 0x00, clear on match for OC1A
    TCCR1 |= (1<<PWM1A);					//1->enable OC1A

    //configure OC1B/_OC1B
    GTCCR = (GTCCR &~((1<<COM1B1) | (1<<COM1B0))) | ((0<<COM1B1) | (1<<COM1B0));	//0b01->set at 0x00, clear on match for OC1B
    GTCCR |= (1<<PWM1B);					//1->enable OC1B

    //set up duty cycles
    OCR1A = sDutyCycle;
    OCR1B = 0xff/2;							//OCR1B = 50% duty cycle -> dc content
    OCR1C = 0xff;							//top at 0xff -> CTC1 not used
    //sDutyCycle = dds_ptr[*dds_msb];

    //set up the ovf interrupt
    TIFR |= (1<<TOV1);						//1->clear the flag
    TIMSK |= (1<<TOIE1);					//1->enable interrupt

#if defined(DDS_USEPLL)
    TCCR1 = (TCCR1 &~0x0f) | (0x03 & 0x0f);	//0x03->4:1 prescaler, 0x02->2:1 prescaler, 0x01->1:1 prescaler
#else
    TCCR1 = (TCCR1 &~0x0f) | (0x01 & 0x0f);	//0x03->4:1 prescaler, 0x02->2:1 prescaler, 0x01->1:1 prescaler
#endif
    //TIMER1 running now

    //ei();									//enable interrupts

}
int main(void) {

    mcu_init();								//reset the mcu
    dds_init();								//initialize the dds
    ei();									//enable interrupts
    while(1) {								//empty loop - execution done via interrupts
    }

    return 0;
}
